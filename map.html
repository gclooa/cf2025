<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Interactive Grid Map</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      font-family: sans-serif;
    }
    #map-container {
      width: 100vw;
      height: 100vh;
      background: #f0f0f0;
      position: relative;
      overflow: hidden;
      cursor: grab;
    }
    #map { 
      position: absolute;
      top: 0;
      left: 0;
      transform-origin: 0 0;
      display: grid;
      grid-template-columns: repeat(20, 60px);
      grid-template-rows: repeat(20, 60px);
      gap: 2px;
    }
    .cell {
      width: 60px;
      height: 60px;
      background: white;
      border: 1px solid #ccc;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: background 0.2s;
    }
    .cell:hover {
      background: #e0e0ff;
    }
  </style>
</head>
<body>
  <div id="map-container">
    <div id="map"></div>
  </div>

  <script>
    const map = document.getElementById("map");
    const container = document.getElementById("map-container");

    // Generate grid
    for (let i = 0; i < 400; i++) {
      const btn = document.createElement("button");
      btn.className = "cell";
      btn.textContent = i + 1;
      btn.onclick = () => alert("Clicked cell " + (i + 1));
      map.appendChild(btn);
    }

    // Panning with inertia
    let isPanning = false;
    let startX, startY;
    let mapX = 0, mapY = 0;
    let velocityX = 0, velocityY = 0;
    let lastMouseX = 0, lastMouseY = 0;
    let lastTimestamp = 0;
    let scale = 1;

    const applyTransform = () => {
      map.style.transform = `translate(${mapX}px, ${mapY}px) scale(${scale})`;
    };

    // Clamp mapX/mapY so that all edges have at least half the
    // container's width/height as padding. If the map is smaller than
    // the required padded area, center it instead.
    const clampPosition = () => {
      const cw = container.clientWidth;
      const ch = container.clientHeight;

      const padX = cw / 2; // half screen width
      const padY = ch / 2; // half screen height

      const mapW = map.offsetWidth * scale;
      const mapH = map.offsetHeight * scale;

      // Allowed range for mapX: [minX, maxX]
      let minX = cw - padX - mapW; // when right edge aligns with container - padX
      let maxX = padX; // left edge may be at most padX from left

      if (minX > maxX) {
        // Map is smaller than the padded area horizontally — center it
        mapX = (cw - mapW) / 2;
      } else {
        if (mapX < minX) {
          mapX = minX;
          velocityX = 0;
        }
        if (mapX > maxX) {
          mapX = maxX;
          velocityX = 0;
        }
      }

      // Allowed range for mapY: [minY, maxY]
      let minY = ch - padY - mapH;
      let maxY = padY;

      if (minY > maxY) {
        // Map is smaller than the padded area vertically — center it
        mapY = (ch - mapH) / 2;
      } else {
        if (mapY < minY) {
          mapY = minY;
          velocityY = 0;
        }
        if (mapY > maxY) {
          mapY = maxY;
          velocityY = 0;
        }
      }
    };

    const animate = (timestamp) => {
      if (!lastTimestamp) lastTimestamp = timestamp;
      const dt = (timestamp - lastTimestamp) / 16;
      lastTimestamp = timestamp;

      // Apply inertia only when not panning
      if (!isPanning) {
        mapX += velocityX * dt;
        mapY += velocityY * dt;

        // Friction
        velocityX *= 0.92;
        velocityY *= 0.92;

        if (Math.abs(velocityX) < 0.01) velocityX = 0;
        if (Math.abs(velocityY) < 0.01) velocityY = 0;
      }

      // Ensure we don't slide past allowed bounds
      clampPosition();

      applyTransform();
      requestAnimationFrame(animate);
    };
    requestAnimationFrame(animate);

    container.addEventListener("mousedown", (e) => {
      isPanning = true;
      container.style.cursor = "grabbing";
      startX = e.clientX - mapX;
      startY = e.clientY - mapY;
      lastMouseX = e.clientX;
      lastMouseY = e.clientY;
      velocityX = 0;
      velocityY = 0;
    });

    window.addEventListener("mousemove", (e) => {
      if (!isPanning) return;

      mapX = e.clientX - startX;
      mapY = e.clientY - startY;

      velocityX = e.clientX - lastMouseX;
      velocityY = e.clientY - lastMouseY;

      lastMouseX = e.clientX;
      lastMouseY = e.clientY;

      // Clamp while dragging so you can't drag past the padded edges
      clampPosition();
      applyTransform();
    });

    window.addEventListener("mouseup", () => {
      isPanning = false;
      container.style.cursor = "grab";
    });

    // Improved zoom (smooth, centered, with limits)
    container.addEventListener("wheel", (e) => {
      e.preventDefault();

      const zoomIntensity = 0.15;
      const oldScale = scale;
      const direction = e.deltaY > 0 ? -1 : 1;
      const newScale = scale + direction * zoomIntensity;

      // Clamp zoom range
      scale = Math.min(Math.max(newScale, 0.3), 4);

      // Get cursor position relative to map
      const rect = container.getBoundingClientRect();
      const offsetX = (e.clientX - rect.left - mapX) / oldScale;
      const offsetY = (e.clientY - rect.top - mapY) / oldScale;

      // Adjust for zoom so that cursor position stays consistent
      mapX = e.clientX - rect.left - offsetX * scale;
      mapY = e.clientY - rect.top - offsetY * scale;

      // Keep the map within allowed padded bounds after zoom
      clampPosition();
      applyTransform();
    });

    // Re-clamp and render on resize
    window.addEventListener('resize', () => {
      clampPosition();
      applyTransform();
    });

    // Initial clamp to enforce padding on load
    clampPosition();
    applyTransform();
  </script>
</body>
</html>
