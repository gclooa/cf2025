<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Interactive Grid Map</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      font-family: sans-serif;
    }
    #map-container {
      width: 100vw;
      height: 100vh;
      background: #f0f0f0;
      position: relative;
      overflow: hidden;
      cursor: grab;
    }
    #map { 
      position: absolute;
      top: 0;
      left: 0;
      transform-origin: 0 0;
      display: grid;
      /* Arrange clusters across the map: 5 clusters per row x 3 rows = 15 clusters total.
         Clusters themselves will define their internal 2x5 grid. */
      grid-template-columns: repeat(5, max-content);
      /* vertical gap between cluster rows: 1 grid cell high.
         Each cell is 60px high with an internal row-gap of 2px,
         so use 1 * (60px + 2px) to space clusters by one cell height. */
      row-gap: calc(1 * (60px + 2px));
      /* horizontal gap between clusters: 2 grid cells wide.
        Each cell is 60px wide with an internal column-gap of 2px,
        so use 2 * (60px + 2px) to space clusters by two cell widths. */
      column-gap: calc(2 * (60px + 2px));
    }

    .cluster {
      display: grid;
      grid-template-columns: repeat(2, 60px);
      grid-template-rows: repeat(5, 60px);
      gap: 2px;
      background: transparent;
      padding: 2px;
      box-sizing: content-box;
      /* Support transform offsets via data attributes */
      transform: var(--cluster-offset, translate(0, 0));
    }
    .cell {
      width: 60px;
      height: 60px;
      background: white;
      border: 1px solid #ccc;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: background 0.2s;
    }
    .cell:hover {
      background: #e0e0ff;
    }
  </style>
</head>
<body>
  <div id="map-container">
    <div id="map"></div>
  </div>

  <script>
    const map = document.getElementById("map");
    const container = document.getElementById("map-container");

    // Generate grid in clusters of 2 columns x 5 rows
    const totalCells = 110;
    const cellsPerCluster = 2 * 5; // 10 cells per cluster
    const clusters = Math.ceil(totalCells / cellsPerCluster);
    let cellNum = 1;

    // Store cluster references for offset manipulation
    const clusterElements = [];

    for (let c = 0; c < clusters; c++) {
      const cluster = document.createElement('div');
      cluster.className = 'cluster';
      cluster.dataset.clusterId = c;

      for (let j = 0; j < cellsPerCluster && cellNum <= totalCells; j++, cellNum++) {
        const btn = document.createElement('button');
        btn.className = 'cell';
        const n = cellNum; // capture current number for the handler
        btn.textContent = n;
        btn.onclick = () => alert("Clicked cell " + n);
        cluster.appendChild(btn);
      }

      map.appendChild(cluster);
      clusterElements.push(cluster);
    }

    // Function to set offset for a cluster by index or element
    // offset can be a string like "translate(100px, 50px)" or an object {x, y}
    const setClusterOffset = (clusterIndexOrElement, offset) => {
      const cluster = typeof clusterIndexOrElement === 'number' 
        ? clusterElements[clusterIndexOrElement] 
        : clusterIndexOrElement;
      
      if (!cluster) return;
      
      let offsetString;
      if (typeof offset === 'string') {
        offsetString = offset;
      } else if (typeof offset === 'object' && offset !== null) {
        const x = offset.x || 0;
        const y = offset.y || 0;
        offsetString = `translate(${x}px, ${y}px)`;
      } else {
        offsetString = 'translate(0, 0)';
      }
      
      cluster.style.setProperty('--cluster-offset', offsetString);
    };

    // Panning with inertia
    let isPanning = false;
    let startX, startY;
    let mapX = 0, mapY = 0;
    let velocityX = 0, velocityY = 0;
    let lastMouseX = 0, lastMouseY = 0;
    let lastTimestamp = 0;
    let scale = 1;

    const applyTransform = () => {
      map.style.transform = `translate(${mapX}px, ${mapY}px) scale(${scale})`;
    };

    // Clamp mapX/mapY so that all edges have at least half the
    // container's width/height as padding. If the map is smaller than
    // the required padded area, center it instead.
    const clampPosition = () => {
      const cw = container.clientWidth;
      const ch = container.clientHeight;

      const padX = cw / 2; // half screen width
      const padY = ch / 2; // half screen height

      const mapW = map.offsetWidth * scale;
      const mapH = map.offsetHeight * scale;

      // Allowed range for mapX: [minX, maxX]
      let minX = cw - padX - mapW; // when right edge aligns with container - padX
      let maxX = padX; // left edge may be at most padX from left

      if (minX > maxX) {
        // Map is smaller than the padded area horizontally — center it
        mapX = (cw - mapW) / 2;
      } else {
        if (mapX < minX) {
          mapX = minX;
          velocityX = 0;
        }
        if (mapX > maxX) {
          mapX = maxX;
          velocityX = 0;
        }
      }

      // Allowed range for mapY: [minY, maxY]
      let minY = ch - padY - mapH;
      let maxY = padY;

      if (minY > maxY) {
        // Map is smaller than the padded area vertically — center it
        mapY = (ch - mapH) / 2;
      } else {
        if (mapY < minY) {
          mapY = minY;
          velocityY = 0;
        }
        if (mapY > maxY) {
          mapY = maxY;
          velocityY = 0;
        }
      }
    };

    const animate = (timestamp) => {
      if (!lastTimestamp) lastTimestamp = timestamp;
      const dt = (timestamp - lastTimestamp) / 16;
      lastTimestamp = timestamp;

      // Apply inertia only when not panning
      if (!isPanning) {
        mapX += velocityX * dt;
        mapY += velocityY * dt;

        // Friction
        velocityX *= 0.92;
        velocityY *= 0.92;

        if (Math.abs(velocityX) < 0.01) velocityX = 0;
        if (Math.abs(velocityY) < 0.01) velocityY = 0;
      }

      // Ensure we don't slide past allowed bounds
      clampPosition();

      applyTransform();
      requestAnimationFrame(animate);
    };
    requestAnimationFrame(animate);

    container.addEventListener("mousedown", (e) => {
      isPanning = true;
      container.style.cursor = "grabbing";
      startX = e.clientX - mapX;
      startY = e.clientY - mapY;
      lastMouseX = e.clientX;
      lastMouseY = e.clientY;
      velocityX = 0;
      velocityY = 0;
    });

    window.addEventListener("mousemove", (e) => {
      if (!isPanning) return;

      mapX = e.clientX - startX;
      mapY = e.clientY - startY;

      velocityX = e.clientX - lastMouseX;
      velocityY = e.clientY - lastMouseY;

      lastMouseX = e.clientX;
      lastMouseY = e.clientY;

      // Clamp while dragging so you can't drag past the padded edges
      clampPosition();
      applyTransform();
    });

    window.addEventListener("mouseup", () => {
      isPanning = false;
      container.style.cursor = "grab";
    });

    // Improved zoom (smooth, centered, with limits)
    container.addEventListener("wheel", (e) => {
      e.preventDefault();

      const zoomIntensity = 0.15;
      const oldScale = scale;
      const direction = e.deltaY > 0 ? -1 : 1;
      const newScale = scale + direction * zoomIntensity;

      // Clamp zoom range
      scale = Math.min(Math.max(newScale, 0.3), 4);

      // Get cursor position relative to map
      const rect = container.getBoundingClientRect();
      const offsetX = (e.clientX - rect.left - mapX) / oldScale;
      const offsetY = (e.clientY - rect.top - mapY) / oldScale;

      // Adjust for zoom so that cursor position stays consistent
      mapX = e.clientX - rect.left - offsetX * scale;
      mapY = e.clientY - rect.top - offsetY * scale;

      // Keep the map within allowed padded bounds after zoom
      clampPosition();
      applyTransform();
    });

    // Re-clamp and render on resize
    window.addEventListener('resize', () => {
      clampPosition();
      applyTransform();
    });

    // Initial clamp to enforce padding on load
    clampPosition();
    applyTransform();

    // Offset third row clusters (indices 10-14) by 12 grids (12 * (60px + 2px) = 744px)
    const thirdRowOffset = 12 * (60 + 2); // 744px
    for (let i = 10; i < 15 && i < clusterElements.length; i++) {
      setClusterOffset(i, {x: thirdRowOffset, y: 0});
    }
  </script>
</body>
</html>
