<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Interactive Grid Map</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      font-family: sans-serif;
    }
    #map-container {
      width: 100vw;
      height: 100vh;
      background: #f0f0f0;
      position: relative;
      overflow: hidden;
      cursor: grab;
    }
    #map {
      position: absolute;
      top: 0;
      left: 0;
      transform-origin: 0 0;
      display: grid;
      grid-template-columns: repeat(20, 60px);
      grid-template-rows: repeat(20, 60px);
      gap: 2px;
    }
    .cell {
      width: 60px;
      height: 60px;
      background: white;
      border: 1px solid #ccc;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: background 0.2s;
    }
    .cell:hover {
      background: #e0e0ff;
    }
  </style>
</head>
<body>
  <div id="map-container">
    <div id="map"></div>
  </div>

  <script>
    const map = document.getElementById("map");
    const container = document.getElementById("map-container");

    // Generate grid
    for (let i = 0; i < 400; i++) {
      const btn = document.createElement("button");
      btn.className = "cell";
      btn.textContent = i + 1;
      btn.onclick = () => alert("Clicked cell " + (i + 1));
      map.appendChild(btn);
    }

    // Panning with inertia
    let isPanning = false;
    let startX, startY;
    let mapX = 0, mapY = 0;
    let velocityX = 0, velocityY = 0;
    let lastMouseX = 0, lastMouseY = 0;
    let lastTimestamp = 0;
    let scale = 1;

    const applyTransform = () => {
      map.style.transform = `translate(${mapX}px, ${mapY}px) scale(${scale})`;
    };

    const animate = (timestamp) => {
      if (!lastTimestamp) lastTimestamp = timestamp;
      const dt = (timestamp - lastTimestamp) / 16;
      lastTimestamp = timestamp;

      // Apply inertia only when not panning
      if (!isPanning) {
        mapX += velocityX * dt;
        mapY += velocityY * dt;

        // Friction
        velocityX *= 0.92;
        velocityY *= 0.92;

        if (Math.abs(velocityX) < 0.01) velocityX = 0;
        if (Math.abs(velocityY) < 0.01) velocityY = 0;
      }

      applyTransform();
      requestAnimationFrame(animate);
    };
    requestAnimationFrame(animate);

    container.addEventListener("mousedown", (e) => {
      isPanning = true;
      container.style.cursor = "grabbing";
      startX = e.clientX - mapX;
      startY = e.clientY - mapY;
      lastMouseX = e.clientX;
      lastMouseY = e.clientY;
      velocityX = 0;
      velocityY = 0;
    });

    window.addEventListener("mousemove", (e) => {
      if (!isPanning) return;

      mapX = e.clientX - startX;
      mapY = e.clientY - startY;

      velocityX = e.clientX - lastMouseX;
      velocityY = e.clientY - lastMouseY;

      lastMouseX = e.clientX;
      lastMouseY = e.clientY;

      applyTransform();
    });

    window.addEventListener("mouseup", () => {
      isPanning = false;
      container.style.cursor = "grab";
    });

    // Improved zoom (smooth, centered, with limits)
    container.addEventListener("wheel", (e) => {
      e.preventDefault();

      const zoomIntensity = 0.15;
      const oldScale = scale;
      const direction = e.deltaY > 0 ? -1 : 1;
      const newScale = scale + direction * zoomIntensity;

      // Clamp zoom range
      scale = Math.min(Math.max(newScale, 0.3), 4);

      // Get cursor position relative to map
      const rect = container.getBoundingClientRect();
      const offsetX = (e.clientX - rect.left - mapX) / oldScale;
      const offsetY = (e.clientY - rect.top - mapY) / oldScale;

      // Adjust for zoom so that cursor position stays consistent
      mapX = e.clientX - rect.left - offsetX * scale;
      mapY = e.clientY - rect.top - offsetY * scale;

      applyTransform();
    });
  </script>
</body>
</html>
